package tower

class DeprecatedCode {
  //  else if (mouseX > 700 && mouseX < 900 && mouseY > 650 && selectedCell == false) {
  //      selectedCell = true
  //      if (selectedCell) {
  //        fill(100, 100, 100)
  //        rect(boxWidth * 3, (0.9 * wHeight).toInt, boxWidth, (0.1 * wHeight).toInt);
  //        exit()
  //      }
  //    }

  //  def what() = {
  //    //    println(fires.toArray.deep.mkString("/n"))
  //    if (!gameIns.attackers.isEmpty) {
  //      for (tower <- gameIns.towers) {
  //        tower.findClose(gameIns.attackers)
  //        if (tower.target.isDefined) {
  //
  //          val time = getTime
  //          val proj = new Fire(tower, tower.target.get, time)
  //          gameIns.fires += proj
  //        }
  //      }
  //    }
  //  }

  //
  //    } else {
  //      gameOver()
  //    }
  ???

  //  if current.x && current.y getCell is route continue
  //  else find another way

  //  def findDirection(from: Tower, to: Attackers): (Int, Int) = {
  //    val tX = from.cell.x
  //    val tY = from.cell.y
  //    val aX = to.cell.x
  //    val aY = to.cell.y
  //    if (from.cell.distance(to.cell) < from.range) {
  //      if (tX > aX && tY > aY) {
  //        //        return (-from.attackSpeed, -from.attackSpeed)
  //        x -= from.attackSpeed
  //        y -= from.attackSpeed
  //      } else if (tX < aX && tY > aY) {
  //        return (from.attackSpeed, -from.attackSpeed)
  //      } else if (tX > aX && tY < aY) {
  //        return (-from.attackSpeed, from.attackSpeed)
  //      } else if (tX < aX && tY < aY) {
  //        return (from.attackSpeed, from.attackSpeed)
  //      }
  //    }
  //    (0, 0)
  //  }
}

